---
title: Linux Shell多进程并发以及并发数控制
author: starifly
date: 2019-06-23T11:10:49+08:00
categories: [shell]
tags: [shell,linux]
draft: true
slug: linux-shell-multi-process-concurrency-control
---

## linux后台进程

Unix 是一个多任务系统，允许多用户同时运行多个程序。shell 的元字符`&`提供了在后台运行不需要键盘输入的程序的方法。输入命令后，其后紧跟`&`字符，该命令就会被送往到 linux 后台执行，而终端又可以继续输入下一个命令了。 

## linux文件描述符

文件描述符（缩写fd）在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。每一个 unix 进程，都会拥有三个标准的文件描述符，来对应三种不同的流（0、1、2）。

每一个文件描述符会对应一个打开文件，同时，不同的文件描述符也可以对应同一个打开文件；同一个文件可以被不同的进程打开，也可以被同一个进程多次打开。

## linux管道

在 Unix 或类 Unix 操作系统中，管道是一个由标准输入输出链接起来的进程集合，因此，每一个进程的输出将直接作为下一个进程的输入，

linux管道包含两种：

- 匿名管道
- 命名管道

***管道有一个特点，如果管道中没有数据，那么取管道数据的操作就会滞留，直到管道内进入数据，然后读出后才会终止这一操作；同理，写入管道的操作如果没有读取管道的操作，这一动作就会滞留。***

### 匿名管道

在 Unix 或类 Unix 操作系统的命令行中，匿名管道使用 ASCII 中垂直线 | 作为匿名管道符，匿名管道的两端是两个普通的，匿名的，打开的文件描述符：一个**只读端**和一个**只写端**，这就让其它进程无法连接到该匿名管道。

例如：

```shell
cat file | less
```

为了执行上面的指令，Shell创建了两个进程来分别执行`cat`和`less`。

有一点值得注意的是两个进程都连接到了管道上，这样写入进程`cat`就将其标准输出（文件描述符为`fd 1`）连接到了管道的写入端，读取进程`less`就将其标准输入（文件描述符为`fd 0`）连接到了管道的读入端。实际上，这两个进程并不知道管道的存在，它们只是从标准文件描述符中读取数据和写入数据。shell 必须要完成相关的工作。

###  命名管道（FIFO，First In First Out）

命名管道也称 FIFO，从语义上来讲，FIFO其实与匿名管道类似，但值得注意：

- 在文件系统中，FIFO 拥有名称，并且是以设备特俗文件的形式存在的；
- 任何进程都可以通过 FIFO 共享数据；
- 除非 FIFO 两端同时有读与写的进程，否则 FIFO 的数据流通将会阻塞；
- 匿名管道是由 shell 自动创建的，存在于内核中；而 FIFO 则是由程序创建的（比如`mkfifo`命令），存在于文件系统中；
- 匿名管道是单向的字节流，而 FIFO 则是双向的字节流；

比如，可以利用FIFO实现单服务器、多客户端的应用程序。

## linux多进程并发数控制

有了上面的知识准备，现在可以开始讲述，**linux多进程并发时，如何控制每次并发的进程数。**

如下脚本实现了 shell 多进程并发 而且并发数 13 的控制：

```Bash
#!/bin/bash

SEND_THREAD_NUM=13   #设置进程数。
tmp_fifofile="/tmp/$$.fifo" # 脚本运行的当前进程ID号作为文件名
trap "exec 6>&-;exec 6<&-;exit 0" 2 # 表示在脚本运行过程中，如果接收到Ctrl+C中断命令，则关闭文件描述符6的读写，并正常退出
mkfifo "$tmp_fifofile" # 新建一个随机fifo管道文件
exec 6<>"$tmp_fifofile" # 定义文件描述符6指向这个fifo管道文件
rm "$tmp_fifofile"
for((i=0;i<$SEND_THREAD_NUM;i++));do
    echo # for循环 往 fifo管道文件中写入13个空行
done >&6

# 以下循环采用 while read 变量 的处理一行数据，看需要吧
for i in `seq 100`;do # 100 次 for 循环 开始
    read -u6 # 从文件描述符6中读取行（实际指向fifo管道)

{
    echo $i # 打印 i
    sleep 3 # 暂停3秒
    echo >&6 # 再次往fifo管道文件中写入一个空行。
} &

# {}部分语句被放入后台作为一个子进程执行，所以不必每次等待3秒后执行
#下一个,这部分的echo $i几乎是同时完成的，当fifo中13个空行读完后 for循环
# 继续等待 read 中读取fifo数据，当后台的13个子进程等待3秒后，按次序
# 排队往fifo输入空行，这样fifo中又有了数据，for语句继续执行

done
wait    #等到后台的进程都执行完毕。
exec 6>&- #删除文件描述符6
exit 0
```

## Reference

- [Linux Shell多进程并发以及并发数控制](https://www.jianshu.com/p/2d60e6513fdd)
- [shell 并发多进程同时执行](https://www.cnblogs.com/zimufeng/p/5089108.html)
